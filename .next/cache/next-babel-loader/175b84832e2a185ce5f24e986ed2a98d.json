{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useRef, useEffect } from \"react\";\n\nconst Canvas5 = props => {\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const c = canvas.getContext(\"2d\"); // size of canvasx\n\n    const imgSize = 512;\n    canvas.width = imgSize;\n    canvas.height = 200; // init image data with black pixels\n\n    const image = c.createImageData(imgSize, imgSize);\n\n    for (let i = 0; i < image.data.length; i += 4) {\n      image.data[i] = 0; // R\n\n      image.data[i + 1] = 0; // G\n\n      image.data[i + 2] = 0; // B\n\n      image.data[i + 3] = 255; // A\n    } // size of our height maps\n\n\n    const mapSize = 1024; // returns the distance of point x,y from the origin 0,0\n\n    const distance = (x, y) => Math.sqrt(x * x + y * y); // init height map 1\n\n\n    const heightMap1 = [];\n\n    for (let u = 0; u < mapSize; u++) {\n      for (let v = 0; v < mapSize; v++) {\n        // index of coordinate in height map array\n        const i = u * mapSize + v; // u,v are coordinates with origin at upper left corner\n        // cx and cy are coordinates with origin at the\n        // center of the map\n\n        const cx = u - mapSize / 2;\n        const cy = v - mapSize / 2; // distance from middle of map\n\n        const d = distance(cx, cy); // stretching so we get the desired ripple density on our map\n\n        const stretch = 3 * Math.PI / (mapSize / 2); // wavy height value between -1 and 1\n\n        const ripple = Math.sin(d * stretch); // wavy height value normalized to 0..1\n\n        const normalized = (ripple + 1) / 2; // height map value 0..128, integer\n\n        heightMap1[i] = Math.floor(normalized * 120);\n      }\n    }\n\n    const heightMap2 = [];\n\n    for (let u = 0; u < mapSize; u++) {\n      for (let v = 0; v < mapSize; v++) {\n        const i = u * mapSize + v;\n        const cx = u - mapSize / 2;\n        const cy = v - mapSize / 2; // skewed distance as input to chaos field calculation,\n        // scaled for smoothness over map distance\n\n        const d1 = distance(0.8 * cx, 1.3 * cy) * 0.022;\n        const d2 = distance(1.35 * cx, 0.45 * cy) * 0.022;\n        const s = Math.sin(d1);\n        const c = Math.cos(d2); // height value between -2 and +2\n\n        const h = s + c; // height value between 0..1\n\n        const normalized = (h + 2) / 4; // height value between 0..127, integer\n\n        heightMap2[i] = Math.floor(normalized * 127);\n      }\n    } // color helpers\n\n\n    const interpolate = (c1, c2, f) => {\n      return {\n        r: Math.floor(c1.r + (c2.r - c1.r) * f),\n        g: Math.floor(c1.g + (c2.g - c1.g) * f),\n        b: Math.floor(c1.b + (c2.b - c1.b) * f)\n      };\n    }; // returns a random color\n\n\n    const randomColor = () => {\n      const r = Math.floor(Math.random() * 255);\n      const g = Math.floor(Math.random() * 255);\n      const b = Math.floor(Math.random() * 255);\n      return {\n        r,\n        g,\n        b\n      };\n    }; // returns a random color palette with 256 color entries\n\n\n    const makeRandomPalette = () => {\n      const c1 = randomColor();\n      const c2 = randomColor();\n      const c3 = randomColor();\n      const c4 = randomColor();\n      const c5 = randomColor();\n      return makeFiveColorGradient(c1, c2, c3, c4, c5);\n    };\n\n    const makeFiveColorGradient = (c1, c2, c3, c4, c5) => {\n      const g = [];\n\n      for (let i = 0; i < 64; i++) {\n        const f = i / 64;\n        g[i] = interpolate(c1, c2, f);\n      }\n\n      for (let i = 64; i < 128; i++) {\n        const f = (i - 64) / 64;\n        g[i] = interpolate(c2, c3, f);\n      }\n\n      for (let i = 128; i < 192; i++) {\n        const f = (i - 128) / 64;\n        g[i] = interpolate(c3, c4, f);\n      }\n\n      for (let i = 192; i < 256; i++) {\n        const f = (i - 192) / 64;\n        g[i] = interpolate(c4, c5, f);\n      }\n\n      return g;\n    }; // offsets for moving height maps\n\n\n    let dx1 = 0;\n    let dy1 = 0;\n    let dx2 = 0;\n    let dy2 = 0; // adjust height maps offsets\n\n    const moveHeightMaps = t => {\n      dx1 = Math.floor((Math.cos(t * 0.0001 + 0.4 + Math.PI) + 1) / 2 * mapSize / 2);\n      dy1 = Math.floor((Math.cos(t * 0.0003 - 0.1) + 1) / 2 * mapSize / 2);\n      dx2 = Math.floor((Math.cos(t * -0.0002 + 1.2) + 1) / 2 * mapSize / 2);\n      dy2 = Math.floor((Math.cos(t * -0.0001 - 0.8 + Math.PI) + 1) / 2 * mapSize / 2);\n    }; // two palettes we interpolate between\n\n\n    const palettes = [makeRandomPalette(), makeRandomPalette()]; // current palette is edstablished durting animation\n\n    let palette = []; // stores whether we're interpolating colors\n    // from palette 0 -> 1 (1) or 1 -> 0 (-1)\n\n    let prevDirection = 0;\n\n    const updatePalette = t => {\n      const timeScale = 0.0002;\n      const x = t * timeScale; // normalized value 0..1 used to interpolate palette colors\n\n      const inter = (Math.cos(x) + 1) / 2; // did we switch direction, and should ergo pick a new palette\n      // random palette to interpolate towards?\n\n      const direction = -Math.sin(x) >= 0 ? 1 : -1;\n\n      if (prevDirection != direction) {\n        prevDirection = direction;\n\n        if (direction == -1) {\n          palettes[0] = makeRandomPalette();\n        } else {\n          palettes[1] = makeRandomPalette();\n        }\n      } // create interpolated palette for current frame\n\n\n      for (let i = 0; i < 256; i++) {\n        palette[i] = interpolate(palettes[0][i], palettes[1][i], inter);\n      }\n    };\n\n    const updateImageData = () => {\n      for (let u = 0; u < imgSize; u++) {\n        for (let v = 0; v < imgSize; v++) {\n          // indexes into height maps for pixel\n          const i = (u + dy1) * mapSize + (v + dx1);\n          const k = (u + dy2) * mapSize + (v + dx2); // index for pixel in image data\n          // remember it's 4 bytes per pixel\n\n          const j = u * imgSize * 4 + v * 4; // // height value of 0..255\n\n          let h = heightMap1[i] + heightMap2[k]; // // get color value from current palette\n\n          let c = palette[h]; // let h = heightMap2[i];\n          // let c = { r: h, g: h, b: h };\n          // set pixel data\n\n          image.data[j] = c.r;\n          image.data[j + 1] = c.g;\n          image.data[j + 2] = c.b;\n        }\n      }\n    }; // helper to create a linear gradient palette\n\n\n    const linearGradient = (c1, c2) => {\n      const g = []; // interpolate between the colors\n      // in the gradient\n\n      for (let i = 0; i < 256; i++) {\n        const f = i / 255;\n        g[i] = interpolate(c1, c2, f);\n      }\n\n      return g;\n    };\n\n    const tick = time => {\n      moveHeightMaps(time);\n      updatePalette(time);\n      updateImageData();\n      c.putImageData(image, 0, 0);\n      window.requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick);\n  });\n  return __jsx(\"canvas\", _extends({\n    ref: canvasRef\n  }, props, {\n    style: {\n      background: \"rgb(13, 13, 33)\",\n      width: \"100%\",\n      height: \"auto\",\n      borderRadius: 12\n    }\n  }));\n};\n\nexport default Canvas5;","map":null,"metadata":{},"sourceType":"module"}