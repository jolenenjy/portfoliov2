{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nvar __jsx = React.createElement;\nimport React, { useRef, useEffect } from \"react\";\n\nvar Canvas5 = function Canvas5(props) {\n  var canvasRef = useRef(null);\n  useEffect(function () {\n    var canvas = canvasRef.current;\n    var c = canvas.getContext(\"2d\"); // size of canvasx\n\n    var imgSize = 512;\n    canvas.width = imgSize;\n    canvas.height = 200; // init image data with black pixels\n\n    var image = c.createImageData(imgSize, imgSize);\n\n    for (var i = 0; i < image.data.length; i += 4) {\n      image.data[i] = 0; // R\n\n      image.data[i + 1] = 0; // G\n\n      image.data[i + 2] = 0; // B\n\n      image.data[i + 3] = 255; // A\n    } // size of our height maps\n\n\n    var mapSize = 1024; // returns the distance of point x,y from the origin 0,0\n\n    var distance = function distance(x, y) {\n      return Math.sqrt(x * x + y * y);\n    }; // init height map 1\n\n\n    var heightMap1 = [];\n\n    for (var u = 0; u < mapSize; u++) {\n      for (var v = 0; v < mapSize; v++) {\n        // index of coordinate in height map array\n        var _i = u * mapSize + v; // u,v are coordinates with origin at upper left corner\n        // cx and cy are coordinates with origin at the\n        // center of the map\n\n\n        var cx = u - mapSize / 2;\n        var cy = v - mapSize / 2; // distance from middle of map\n\n        var d = distance(cx, cy); // stretching so we get the desired ripple density on our map\n\n        var stretch = 3 * Math.PI / (mapSize / 2); // wavy height value between -1 and 1\n\n        var ripple = Math.sin(d * stretch); // wavy height value normalized to 0..1\n\n        var normalized = (ripple + 1) / 2; // height map value 0..128, integer\n\n        heightMap1[_i] = Math.floor(normalized * 120);\n      }\n    }\n\n    var heightMap2 = [];\n\n    for (var _u = 0; _u < mapSize; _u++) {\n      for (var _v = 0; _v < mapSize; _v++) {\n        var _i2 = _u * mapSize + _v;\n\n        var _cx = _u - mapSize / 2;\n\n        var _cy = _v - mapSize / 2; // skewed distance as input to chaos field calculation,\n        // scaled for smoothness over map distance\n\n\n        var d1 = distance(0.8 * _cx, 1.3 * _cy) * 0.022;\n        var d2 = distance(1.35 * _cx, 0.45 * _cy) * 0.022;\n        var s = Math.sin(d1);\n\n        var _c = Math.cos(d2); // height value between -2 and +2\n\n\n        var h = s + _c; // height value between 0..1\n\n        var _normalized = (h + 2) / 4; // height value between 0..127, integer\n\n\n        heightMap2[_i2] = Math.floor(_normalized * 127);\n      }\n    } // color helpers\n\n\n    var interpolate = function interpolate(c1, c2, f) {\n      return {\n        r: Math.floor(c1.r + (c2.r - c1.r) * f),\n        g: Math.floor(c1.g + (c2.g - c1.g) * f),\n        b: Math.floor(c1.b + (c2.b - c1.b) * f)\n      };\n    }; // returns a random color\n\n\n    var randomColor = function randomColor() {\n      var r = Math.floor(Math.random() * 255);\n      var g = Math.floor(Math.random() * 255);\n      var b = Math.floor(Math.random() * 255);\n      return {\n        r: r,\n        g: g,\n        b: b\n      };\n    }; // returns a random color palette with 256 color entries\n\n\n    var makeRandomPalette = function makeRandomPalette() {\n      var c1 = randomColor();\n      var c2 = randomColor();\n      var c3 = randomColor();\n      var c4 = randomColor();\n      var c5 = randomColor();\n      return makeFiveColorGradient(c1, c2, c3, c4, c5);\n    };\n\n    var makeFiveColorGradient = function makeFiveColorGradient(c1, c2, c3, c4, c5) {\n      var g = [];\n\n      for (var _i3 = 0; _i3 < 64; _i3++) {\n        var f = _i3 / 64;\n        g[_i3] = interpolate(c1, c2, f);\n      }\n\n      for (var _i4 = 64; _i4 < 128; _i4++) {\n        var _f = (_i4 - 64) / 64;\n\n        g[_i4] = interpolate(c2, c3, _f);\n      }\n\n      for (var _i5 = 128; _i5 < 192; _i5++) {\n        var _f2 = (_i5 - 128) / 64;\n\n        g[_i5] = interpolate(c3, c4, _f2);\n      }\n\n      for (var _i6 = 192; _i6 < 256; _i6++) {\n        var _f3 = (_i6 - 192) / 64;\n\n        g[_i6] = interpolate(c4, c5, _f3);\n      }\n\n      return g;\n    }; // offsets for moving height maps\n\n\n    var dx1 = 0;\n    var dy1 = 0;\n    var dx2 = 0;\n    var dy2 = 0; // adjust height maps offsets\n\n    var moveHeightMaps = function moveHeightMaps(t) {\n      dx1 = Math.floor((Math.cos(t * 0.0001 + 0.4 + Math.PI) + 1) / 2 * mapSize / 2);\n      dy1 = Math.floor((Math.cos(t * 0.0003 - 0.1) + 1) / 2 * mapSize / 2);\n      dx2 = Math.floor((Math.cos(t * -0.0002 + 1.2) + 1) / 2 * mapSize / 2);\n      dy2 = Math.floor((Math.cos(t * -0.0001 - 0.8 + Math.PI) + 1) / 2 * mapSize / 2);\n    }; // two palettes we interpolate between\n\n\n    var palettes = [makeRandomPalette(), makeRandomPalette()]; // current palette is edstablished durting animation\n\n    var palette = []; // stores whether we're interpolating colors\n    // from palette 0 -> 1 (1) or 1 -> 0 (-1)\n\n    var prevDirection = 0;\n\n    var updatePalette = function updatePalette(t) {\n      var timeScale = 0.0002;\n      var x = t * timeScale; // normalized value 0..1 used to interpolate palette colors\n\n      var inter = (Math.cos(x) + 1) / 2; // did we switch direction, and should ergo pick a new palette\n      // random palette to interpolate towards?\n\n      var direction = -Math.sin(x) >= 0 ? 1 : -1;\n\n      if (prevDirection != direction) {\n        prevDirection = direction;\n\n        if (direction == -1) {\n          palettes[0] = makeRandomPalette();\n        } else {\n          palettes[1] = makeRandomPalette();\n        }\n      } // create interpolated palette for current frame\n\n\n      for (var _i7 = 0; _i7 < 256; _i7++) {\n        palette[_i7] = interpolate(palettes[0][_i7], palettes[1][_i7], inter);\n      }\n    };\n\n    var updateImageData = function updateImageData() {\n      for (var _u2 = 0; _u2 < imgSize; _u2++) {\n        for (var _v2 = 0; _v2 < imgSize; _v2++) {\n          // indexes into height maps for pixel\n          var _i8 = (_u2 + dy1) * mapSize + (_v2 + dx1);\n\n          var k = (_u2 + dy2) * mapSize + (_v2 + dx2); // index for pixel in image data\n          // remember it's 4 bytes per pixel\n\n          var j = _u2 * imgSize * 4 + _v2 * 4; // // height value of 0..255\n\n          var _h = heightMap1[_i8] + heightMap2[k]; // // get color value from current palette\n\n\n          var _c2 = palette[_h]; // let h = heightMap2[i];\n          // let c = { r: h, g: h, b: h };\n          // set pixel data\n\n          image.data[j] = _c2.r;\n          image.data[j + 1] = _c2.g;\n          image.data[j + 2] = _c2.b;\n        }\n      }\n    }; // helper to create a linear gradient palette\n\n\n    var linearGradient = function linearGradient(c1, c2) {\n      var g = []; // interpolate between the colors\n      // in the gradient\n\n      for (var _i9 = 0; _i9 < 256; _i9++) {\n        var f = _i9 / 255;\n        g[_i9] = interpolate(c1, c2, f);\n      }\n\n      return g;\n    };\n\n    var tick = function tick(time) {\n      moveHeightMaps(time);\n      updatePalette(time);\n      updateImageData();\n      c.putImageData(image, 0, 0);\n      window.requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick);\n  });\n  return __jsx(\"canvas\", _extends({\n    ref: canvasRef\n  }, props, {\n    style: {\n      background: \"rgb(13, 13, 33)\",\n      width: \"100%\",\n      height: \"auto\",\n      borderRadius: 12\n    }\n  }));\n};\n\nexport default Canvas5;","map":null,"metadata":{},"sourceType":"module"}